diff -urP -x .git -x .obj darknet_old/cfg/yolov3.cfg darknet_new/cfg/yolov3.cfg
--- darknet_old/cfg/yolov3.cfg	2019-12-26 15:24:32.699034962 +0900
+++ darknet_new/cfg/yolov3.cfg	2019-12-20 16:01:03.607486239 +0900
@@ -1,10 +1,10 @@
 [net]
 # Testing
-# batch=1
-# subdivisions=1
+batch=1
+subdivisions=1
 # Training
-batch=64
-subdivisions=16
+# batch=64
+# subdivisions=16
 width=608
 height=608
 channels=3
diff -urP -x .git -x .obj darknet_old/examples/coco.c darknet_new/examples/coco.c
--- darknet_old/examples/coco.c	2019-12-26 15:24:33.035048329 +0900
+++ darknet_new/examples/coco.c	2019-12-20 16:01:03.607486239 +0900
@@ -353,5 +353,5 @@
     else if(0==strcmp(argv[2], "train")) train_coco(cfg, weights);
     else if(0==strcmp(argv[2], "valid")) validate_coco(cfg, weights);
     else if(0==strcmp(argv[2], "recall")) validate_coco_recall(cfg, weights);
-    else if(0==strcmp(argv[2], "demo")) demo(cfg, weights, thresh, cam_index, filename, coco_classes, 80, frame_skip, prefix, avg, .5, 0,0,0,0);
+    else if(0==strcmp(argv[2], "demo")) demo_with_opencv(cfg, weights, thresh, cam_index, filename, coco_classes, 80, frame_skip, prefix, avg, .5, 0,0,0,0,4,1);
 }
diff -urP -x .git -x .obj darknet_old/examples/detector.c darknet_new/examples/detector.c
--- darknet_old/examples/detector.c	2019-12-26 15:24:33.035048329 +0900
+++ darknet_new/examples/detector.c	2019-12-20 16:01:03.607486239 +0900
@@ -827,6 +827,8 @@
     int width = find_int_arg(argc, argv, "-w", 0);
     int height = find_int_arg(argc, argv, "-h", 0);
     int fps = find_int_arg(argc, argv, "-fps", 0);
+	int opencv_buffer_size=find_int_arg(argc,argv,"-buffer_size",4);
+	int apply_offset=find_arg(argc, argv, "-apply_offset");
     //int class = find_int_arg(argc, argv, "-class", 0);
 
     char *datacfg = argv[3];
@@ -843,7 +845,8 @@
         int classes = option_find_int(options, "classes", 20);
         char *name_list = option_find_str(options, "names", "data/names.list");
         char **names = get_labels(name_list);
-        demo(cfg, weights, thresh, cam_index, filename, names, classes, frame_skip, prefix, avg, hier_thresh, width, height, fps, fullscreen);
+//        demo(cfg, weights, thresh, cam_index, filename, names, classes, frame_skip, prefix, avg, hier_thresh, width, height, fps, fullscreen);
+        demo_with_opencv(cfg, weights, thresh, cam_index, filename, names, classes, frame_skip, prefix, avg, hier_thresh, width, height, fps, fullscreen, opencv_buffer_size, apply_offset);
     }
     //else if(0==strcmp(argv[2], "extract")) extract_detector(datacfg, cfg, weights, cam_index, filename, class, thresh, frame_skip);
     //else if(0==strcmp(argv[2], "censor")) censor_detector(datacfg, cfg, weights, cam_index, filename, class, thresh, frame_skip);
diff -urP -x .git -x .obj darknet_old/examples/yolo.c darknet_new/examples/yolo.c
--- darknet_old/examples/yolo.c	2019-12-26 15:24:33.043048647 +0900
+++ darknet_new/examples/yolo.c	2019-12-20 16:01:03.607486239 +0900
@@ -323,5 +323,5 @@
     else if(0==strcmp(argv[2], "train")) train_yolo(cfg, weights);
     else if(0==strcmp(argv[2], "valid")) validate_yolo(cfg, weights);
     else if(0==strcmp(argv[2], "recall")) validate_yolo_recall(cfg, weights);
-    else if(0==strcmp(argv[2], "demo")) demo(cfg, weights, thresh, cam_index, filename, voc_names, 20, frame_skip, prefix, avg, .5, 0,0,0,0);
+    else if(0==strcmp(argv[2], "demo")) demo_with_opencv(cfg, weights, thresh, cam_index, filename, voc_names, 20, frame_skip, prefix, avg, .5, 0,0,0,0,4,0);
 }
diff -urP -x .git -x .obj darknet_old/include/darknet.h darknet_new/include/darknet.h
--- darknet_old/include/darknet.h	2019-12-26 15:24:33.043048647 +0900
+++ darknet_new/include/darknet.h	2019-12-20 16:01:03.607486239 +0900
@@ -673,6 +673,7 @@
 image *get_weights(layer l);
 
 void demo(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int frame_skip, char *prefix, int avg, float hier_thresh, int w, int h, int fps, int fullscreen);
+void demo_with_opencv(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int frame_skip, char *prefix, int avg, float hier_thresh, int w, int h, int fps, int fullscreen, int opencv_buffer_size, int apply_offset);
 void get_detection_detections(layer l, int w, int h, float thresh, detection *dets);
 
 char *option_find_str(list *l, char *key, char *def);
diff -urP -x .git -x .obj darknet_old/Makefile darknet_new/Makefile
--- darknet_old/Makefile	2019-12-26 15:24:32.639032574 +0900
+++ darknet_new/Makefile	2019-12-20 16:01:03.607486239 +0900
@@ -1,13 +1,14 @@
-GPU=0
-CUDNN=0
-OPENCV=0
+GPU=1
+CUDNN=1
+OPENCV=1
 OPENMP=0
 DEBUG=0
 
 ARCH= -gencode arch=compute_30,code=sm_30 \
       -gencode arch=compute_35,code=sm_35 \
       -gencode arch=compute_50,code=[sm_50,compute_50] \
-      -gencode arch=compute_52,code=[sm_52,compute_52]
+      -gencode arch=compute_52,code=[sm_52,compute_52]\
+      -gencode arch=compute_72,code=[sm_72,compute_72]
 #      -gencode arch=compute_20,code=[sm_20,sm_21] \ This one is deprecated?
 
 # This is what I use, uncomment if you know your arch and want to specify
diff -urP -x .git -x .obj darknet_old/src/demo.c darknet_new/src/demo.c
--- darknet_old/src/demo.c	2019-12-26 15:24:33.063049443 +0900
+++ darknet_new/src/demo.c	2019-12-26 15:25:51.246147696 +0900
@@ -1,3 +1,4 @@
+#define _GNU_SOURCE
 #include "network.h"
 #include "detection_layer.h"
 #include "region_layer.h"
@@ -8,11 +9,14 @@
 #include "image.h"
 #include "demo.h"
 #include <sys/time.h>
+#include <unistd.h>
 
 #define DEMO 1
 
 #ifdef OPENCV
 
+#define start_log 10
+
 static char **demo_names;
 static image **demo_alphabet;
 static int demo_classes;
@@ -35,6 +39,32 @@
 static int demo_total = 0;
 double demo_time;
 
+static int count=0;
+
+float camera_fps=0;
+float *ptr_camera_fps=&camera_fps;
+long int frame_number[3];
+double frame_timestamp[3];
+static double detect_start;
+static double detect_time;
+static double display_start;
+static double display_end;
+static double display_time;
+static double fetch_start;
+static double fetch_time;
+static double image_waiting_time;
+static double E2E_delay;
+static double slack;
+static int offset;
+int apply_offset_=0;
+
+double gettimeafterboot()
+{
+	struct timespec time_after_boot;
+	clock_gettime(CLOCK_MONOTONIC,&time_after_boot);
+	return (time_after_boot.tv_sec*1000+time_after_boot.tv_nsec*0.000001);
+}
+
 detection *get_network_boxes(network *net, int w, int h, float thresh, float hier, int *map, int relative, int *num);
 
 int size_network(network *net)
@@ -84,6 +114,7 @@
 
 void *detect_in_thread(void *ptr)
 {
+	detect_start=gettimeafterboot();
     running = 1;
     float nms = .4;
 
@@ -91,37 +122,11 @@
     float *X = buff_letter[(buff_index+2)%3].data;
     network_predict(net, X);
 
-    /*
-       if(l.type == DETECTION){
-       get_detection_boxes(l, 1, 1, demo_thresh, probs, boxes, 0);
-       } else */
     remember_network(net);
     detection *dets = 0;
     int nboxes = 0;
     dets = avg_predictions(net, &nboxes);
 
-
-    /*
-       int i,j;
-       box zero = {0};
-       int classes = l.classes;
-       for(i = 0; i < demo_detections; ++i){
-       avg[i].objectness = 0;
-       avg[i].bbox = zero;
-       memset(avg[i].prob, 0, classes*sizeof(float));
-       for(j = 0; j < demo_frame; ++j){
-       axpy_cpu(classes, 1./demo_frame, dets[j][i].prob, 1, avg[i].prob, 1);
-       avg[i].objectness += dets[j][i].objectness * 1./demo_frame;
-       avg[i].bbox.x += dets[j][i].bbox.x * 1./demo_frame;
-       avg[i].bbox.y += dets[j][i].bbox.y * 1./demo_frame;
-       avg[i].bbox.w += dets[j][i].bbox.w * 1./demo_frame;
-       avg[i].bbox.h += dets[j][i].bbox.h * 1./demo_frame;
-       }
-    //copy_cpu(classes, dets[0][i].prob, 1, avg[i].prob, 1);
-    //avg[i].objectness = dets[0][i].objectness;
-    }
-     */
-
     if (nms > 0) do_nms_obj(dets, nboxes, l.classes, nms);
 
     printf("\033[2J");
@@ -134,24 +139,38 @@
 
     demo_index = (demo_index + 1)%demo_frame;
     running = 0;
-    return 0;
+	if(count>=start_log) {
+	detect_time=gettimeafterboot()-detect_start;
+	} 
+	return 0;
 }
 
 void *fetch_in_thread(void *ptr)
 {
+	if(apply_offset_) usleep(offset*1000);
+	else {};
+	fetch_start=gettimeafterboot();
     free_image(buff[buff_index]);
-    buff[buff_index] = get_image_from_stream(cap);
+    buff[buff_index] = get_image_from_stream_timestamp(cap,frame_timestamp,buff_index);
+
     if(buff[buff_index].data == 0) {
         demo_done = 1;
         return 0;
     }
     letterbox_image_into(buff[buff_index], net->w, net->h, buff_letter[buff_index]);
+	if(count>=start_log){
+		fetch_time=gettimeafterboot()-fetch_start;
+		image_waiting_time=frame_timestamp[buff_index]-fetch_start;  
+	}
     return 0;
 }
 
 void *display_in_thread(void *ptr)
 {
-    int c = show_image(buff[(buff_index + 1)%3], "Demo", 1);
+	display_start=gettimeafterboot();
+	int c;
+	if(!apply_offset_) c = show_image(buff[(buff_index + 1)%3], "Demo", 1); 
+	else c = show_image(buff[(buff_index + 2)%3], "Demo", 1); 
     if (c != -1) c = c%256;
     if (c == 27) {
         demo_done = 1;
@@ -167,6 +186,12 @@
         demo_hier -= .02;
         if(demo_hier <= .0) demo_hier = .0;
     }
+	if(count>=start_log){
+		display_end=gettimeafterboot();
+		display_time=display_end-display_start;
+		if(!apply_offset_) E2E_delay=display_end-frame_timestamp[(buff_index+1)%3];
+		else E2E_delay=display_end-frame_timestamp[(buff_index+2)%3];
+	}
     return 0;
 }
 
@@ -184,7 +209,7 @@
     }
 }
 
-void demo(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int delay, char *prefix, int avg_frames, float hier, int w, int h, int frames, int fullscreen)
+void demo_with_opencv(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int delay, char *prefix, int avg_frames, float hier, int w, int h, int frames, int fullscreen, int opencv_buffer_size, int apply_offset)
 {
     //demo_frame = avg_frames;
     image **alphabet = load_alphabet();
@@ -198,7 +223,7 @@
     set_batch_network(net, 1);
     pthread_t detect_thread;
     pthread_t fetch_thread;
-
+	apply_offset_=apply_offset;
     srand(2222222);
 
     int i;
@@ -213,7 +238,7 @@
         printf("video file: %s\n", filename);
         cap = open_video_stream(filename, 0, 0, 0, 0);
     }else{
-        cap = open_video_stream(0, cam_index, w, h, frames);
+        cap = open_video_stream_cam_fps(0, cam_index, w, h, frames, ptr_camera_fps,opencv_buffer_size);
     }
 
     if(!cap) error("Couldn't connect to webcam.\n");
@@ -225,32 +250,48 @@
     buff_letter[1] = letterbox_image(buff[0], net->w, net->h);
     buff_letter[2] = letterbox_image(buff[0], net->w, net->h);
 
-    int count = 0;
+
     if(!prefix){
         make_window("Demo", 1352, 1013, fullscreen);
     }
+	demo_time=gettimeafterboot();
 
-    demo_time = what_time_is_it_now();
-
-    while(!demo_done){
-        buff_index = (buff_index + 1) %3;
-        if(pthread_create(&fetch_thread, 0, fetch_in_thread, 0)) error("Thread creation failed");
-        if(pthread_create(&detect_thread, 0, detect_in_thread, 0)) error("Thread creation failed");
-        if(!prefix){
-            fps = 1./(what_time_is_it_now() - demo_time);
-            demo_time = what_time_is_it_now();
-            display_in_thread(0);
-        }else{
-            char name[256];
-            sprintf(name, "%s_%08d", prefix, count);
-            save_image(buff[(buff_index + 1)%3], name);
-        }
-        pthread_join(fetch_thread, 0);
-        pthread_join(detect_thread, 0);
-        ++count;
-    }
+		while(!demo_done){
+			if(pthread_create(&fetch_thread, 0, fetch_in_thread, 0)) error("Thread creation failed");
+			if(!apply_offset_) if(pthread_create(&detect_thread, 0, detect_in_thread, 0)) error("Thread creation failed");
+			if(!prefix){
+				fps=1./(gettimeafterboot()-demo_time)*1000;
+				demo_time=gettimeafterboot();
+				if(apply_offset_) detect_in_thread(0);
+				display_in_thread(0);
+	
+	        }else{
+	            char name[256];
+	            sprintf(name, "%s_%08d", prefix, count);
+	            save_image(buff[(buff_index + 2)%3], name);
+	        }
+	        pthread_join(fetch_thread, 0);
+	        if(!apply_offset_) pthread_join(detect_thread, 0);
+			printf("offset : %d\n", offset);
+			if(count>=start_log){
+				slack=(detect_time+display_time)-(offset+fetch_time);
+				if(apply_offset){
+					int n;
+					int old_offset=offset;
+					if((old_offset+fetch_time)<(detect_time+display_time)){ 
+						offset+=1000./(camera_fps);
+					}else{
+						for(n=1;((old_offset+image_waiting_time-n*1000./camera_fps)>(detect_time));n++){
+							offset=old_offset+image_waiting_time-(n+0.5)*1000./(camera_fps);
+						}
+					}
+				}
+			printf("E2E_delay : %f\n",E2E_delay);
+			}
+		count++;
+	   	buff_index = (buff_index + 1) %3;
+		}
 }
-
 /*
    void demo_compare(char *cfg1, char *weight1, char *cfg2, char *weight2, float thresh, int cam_index, const char *filename, char **names, int classes, int delay, char *prefix, int avg_frames, float hier, int w, int h, int frames, int fullscreen)
    {
@@ -345,5 +386,12 @@
 {
     fprintf(stderr, "Demo needs OpenCV for webcam images.\n");
 }
+
+
+
+
+
 #endif
 
+
+
diff -urP -x .git -x .obj darknet_old/src/image.h darknet_new/src/image.h
--- darknet_old/src/image.h	2019-12-26 15:24:33.071049761 +0900
+++ darknet_new/src/image.h	2019-12-20 16:01:03.607486239 +0900
@@ -15,7 +15,9 @@
 
 #ifdef OPENCV
 void *open_video_stream(const char *f, int c, int w, int h, int fps);
+void *open_video_stream_cam_fps(const char *f, int c, int w, int h, int fps,float *camera_fps,int opencv_buffer_size);
 image get_image_from_stream(void *p);
+image get_image_from_stream_timestamp(void *p,double *frame_timestamp,int buff_index);
 image load_image_cv(char *filename, int channels);
 int show_image_cv(image im, const char* name, int ms);
 #endif
diff -urP -x .git -x .obj darknet_old/src/image_opencv.cpp darknet_new/src/image_opencv.cpp
--- darknet_old/src/image_opencv.cpp	2019-12-26 15:24:33.071049761 +0900
+++ darknet_new/src/image_opencv.cpp	2019-12-20 16:01:03.607486239 +0900
@@ -73,11 +73,25 @@
     else cap = new VideoCapture(c);
     if(!cap->isOpened()) return 0;
     if(w) cap->set(CV_CAP_PROP_FRAME_WIDTH, w);
-    if(h) cap->set(CV_CAP_PROP_FRAME_HEIGHT, w);
-    if(fps) cap->set(CV_CAP_PROP_FPS, w);
+    if(h) cap->set(CV_CAP_PROP_FRAME_HEIGHT, h);
+    if(fps) cap->set(CV_CAP_PROP_FPS, fps);
     return (void *) cap;
 }
 
+void *open_video_stream_cam_fps(const char *f, int c, int w, int h, int fps,float *camera_fps, int opencv_buffer_size)
+{
+    VideoCapture *cap;
+    if(f) cap = new VideoCapture(f);
+    else cap = new VideoCapture(c,1,opencv_buffer_size);
+    if(!cap->isOpened()) return 0;
+    if(w) cap->set(CV_CAP_PROP_FRAME_WIDTH, w);
+    if(h) cap->set(CV_CAP_PROP_FRAME_HEIGHT, h);
+    if(fps) cap->set(CV_CAP_PROP_FPS, fps);
+	*camera_fps=cap->get(CV_CAP_PROP_FPS);
+    return (void *) cap;
+}
+
+
 image get_image_from_stream(void *p)
 {
     VideoCapture *cap = (VideoCapture *)p;
@@ -87,6 +101,16 @@
     return mat_to_image(m);
 }
 
+image get_image_from_stream_timestamp(void *p,double *frame_timestamp,int buff_index)
+{
+    VideoCapture *cap = (VideoCapture *)p;
+    Mat m;
+    *cap >> m;
+    if(m.empty()) return make_empty_image(0,0,0);
+    *(frame_timestamp+buff_index)=cap->get(CV_CAP_PROP_POS_MSEC);
+    return mat_to_image(m);
+}
+
 image load_image_cv(char *filename, int channels)
 {
     int flag = -1;
